# Bash Pitfalls Case 07
## [[ \$foo > 7 ]]

这里有多个问题。 首先， `[[` 命令不应仅用于计算算术表达式。 它应该用于涉及受支持的测试运算符之一的测试表达式。 尽管从技术上讲，您可以使用某些 `[[` 运算符进行数学运算，但只有将其与表达式中某处的非数学测试运算符之一结合使用才有意义。 如果您只想进行数字比较（或任何其他 shell 算术），最好使用 `(())` 代替：

```shell
# Bash / Ksh
((foo > 7))     # 正确!
[[ foo -gt 7 ]] # 这样也行, 但并不常见。 使用 ((...)) 代替。
```

如果在 `[[ ]]` 中使用 `>` 运算符，则会将其视为字符串比较（按语言环境测试整理顺序），而不是整数比较。 这有时可能会奏效，但在您最不期望的时候就会出错。 如果在 `[ ]` 中使用 `>`，则会 更糟糕：这是一个输出重定向。 你会在你的目录中得到一个名为 7 的文件，只要 `$foo` 不为空，测试就会成功。

如果需要严格的 POSIX 一致性，并且 `((` 不可用，则使用 `[` 的正确替代方法是:

```shell
# POSIX
[ "$foo" -gt 7 ]       # 同样正确!
[ "$((foo > 7))" -ne 0 ] # POSIX 兼容等效于 ((，用于更一般的数学运算。
```

如果 `$foo` 的内容没有被清理并且它的内容不在你的控制之下（例如它来自外部来源），那么除了 `[ "$foo" -gt 7 ]` 之外的所有内容，都构成任意命令注入漏洞，因为 $foo 的内容被解释为算术表达式（例如， `a[$(reboot)]` 算术表达式将在解析时运行 `reboot` 命令）。 内置函数 `[` 要求操作数为十进制整数，因此不受影响。 但是引用 `$foo` 很重要，否则您仍然会遇到命令注入漏洞（例如使用 `-v a[$(reboot)] -o 8` 之类的值）。

如果无法保证任何算术上下文（包括 `((`、`let`、数组索引）或 `[[ ... ]]` 涉及数字比较的测试表达式）的输入，那么您必须始终在解析表达式之前，验证您的输入。

> [!TIP]
> [How can I tell whether a variable contains a valid number?](http://mywiki.wooledge.org/BashFAQ/054)

```shell
# POSIX
case $foo in
    ("" | *[!0123456789]*)
        printf '$foo is not a sequence of decimal digits: "%s"\n' "$foo" >&2
        exit 1
        ;;
    *)
        [ "$foo" -gt 7 ]
esac
```

请注意，由于 `[`/`test` 的算术运算符需要*十进制*整数，例如 010 将被解释为数字 10，而不是以八进制表示的 8。 在 bash 中，`[ 010 -gt 8 ]` 将返回 true，而 `[[ 010 -gt 8 ]]` 和 `(( 010 > 8 ))` 将返回 false。

## 拓展阅读

[How can I tell whether a variable contains a valid number?](http://mywiki.wooledge.org/BashFAQ/054)