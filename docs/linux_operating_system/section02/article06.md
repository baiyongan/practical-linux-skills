# 06 | x86架构：有了开放的架构，才能打造开放的营商环境

## 计算机的工作模式

![06_01_computer_hardware.png](https://i.loli.net/2021/08/04/aShw2M8OeJBFlnW.png)

### CPU

对于一个计算机来讲，最核心的就是 **CPU（Central Processing Unit，中央处理器）**。这是这台计算机的大脑，所有的设备都围绕它展开。

CPU 和其他设备连接，要靠一种叫作**总线（Bus）**的东西，也就是主板上密密麻麻的集成电路，这些东西组成了 CPU 和其他设备的高速通道。

而这些设备中，最重要的是内存（Memory）。单靠 CPU 是没办法完成计算任务的，因为很多复杂的计算任务都需要将中间结果保存下来，然后基于中间结果进行进一步的计算。CPU 本身没办法保存这么多中间结果，这就要依赖内存了。

总线上还有一些其他设备，例如显卡会连接显示器、磁盘控制器会连接硬盘、USB 控制器会连接键盘和鼠标等等。

**CPU 和内存是完成计算任务的核心组件。**

#### CPU 的组成

CPU 其实也不是单纯的一块，它包括三个部分，运算单元、数据单元和控制单元。

##### 运算单元

运算单元只管算，例如做加法、做位移等等。但是，它不知道应该算哪些数据，运算结果应该放在哪里。

##### 数据单元

数据单元包括 CPU 内部的缓存和寄存器组，空间很小，但是速度飞快，可以暂时存放数据和运算结果。如此一来，运算单元计算的数据就不必每次都要经过总线，到内存里面现拿，否则就太慢了。

- CPU 内部缓存

- 寄存器组

##### 控制单元

控制单元是一个统一的指挥中心，它可以获得下一条指令，然后执行这条指令。这个指令会指导运算单元取出数据单元中的某几个数据，计算出个结果，然后放在数据单元的某个地方。

![06_02_disk_memory_cpu.png](https://i.loli.net/2021/08/04/Hdus7cyOWzpAQxb.png)

- 指令指针寄存器

程序运行的过程中要操作的数据和产生的计算结果，都会放在数据段里面。**那么 CPU 怎么执行这些程序，操作这些数据，产生一些结果，并写入回内存呢？**

CPU 的控制单元里面，有一个指令指针寄存器，它里面存放的是下一条指令在内存中的地址。控制单元会不停地将代码段的指令拿进来，先放入指令寄存器。

当前的指令分两部分，一部分是做什么操作，例如是加法还是位移；一部分是操作哪些数据。

要执行这条指令，就要把第一部分交给运算单元，第二部分交给数据单元。

数据单元根据数据的地址，从数据段里读到数据寄存器里，就可以参与运算了。运算单元做完运算，产生的结果会暂存在数据单元的数据寄存器里。最终，会有指令将数据写回内存中的数据段。

> [!NOTE]
> 对于不同的进程，CPU 有不同的寄存器，专门保存当前处理进程的代码段的起始地址，以及数据段的起始地址。**进程切换（Process Switch）**。是一个多任务系统的必备操作


- 段寄存器

### 内存

### 总线

总线上主要有两类数据，一个是地址数据，也就是想拿内存中哪个位置的数据，这类总线叫**地址总线（Address Bus）**；另一类是真正的数据，这类总线叫**数据总线（Data Bus）**。

CPU 和内存来来回回传数据，靠的都是总线。总线其实有点像连接 CPU 和内存这两个设备的高速公路，说总线到底是多少位，就类似说高速公路有几个车道。但是这两种总线的位数意义是不同的。

#### 系统总线

#### 内存总线

- 地址总线

**地址总线的位数，决定了能访问的地址范围到底有多广。** 例如只有两位，那 CPU 就只能认 00，01，10，11 四个位置，超过四个位置，就区分不出来了。位数越多，能够访问的位置就越多，能管理的内存的范围也就越广。

- 数据总线

**数据总线的位数，决定了一次能拿多少个数据进来。** 例如只有两位，那 CPU 一次只能从内存拿两位数。要想拿八位，就要拿四次。位数越多，一次拿的数据就越多，访问速度也就越快。

#### I/O 总线

## x86 开放平台

> [!NOTE]
> 能够开放自己的技术是一件了不起的事。从技术和发展的层面来讲，它会使得一项技术大面积铺开，形成行业标准。就比如现在常用的 Android 手机，如果没有开放的 Android 系统，我们也没办法享受到这么多不同类型的手机。

历史将 x86 平台推到了**开放、统一、兼容**的位置。

![06_03_x86_parameter.png](https://i.loli.net/2021/08/04/saHidFNmTSBMZvY.png)

### x86 原理

![06_04_cpu_component.png](https://i.loli.net/2021/08/04/lWp8FHdGeMr1XoT.png)

#### 数据单元的寄存器

数据单元中，为了暂存数据，8086 处理器内部有 8 个 16 位的通用寄存器，也就是 CPU 内部的数据单元，分别是 AX、BX、CX、DX、SP、BP、SI、DI。这些寄存器主要用于在计算过程中暂存数据。

这些寄存器比较灵活，其中 AX、BX、CX、DX 可以分成两个 8 位的寄存器来使用，分别是 AH、AL、BH、BL、CH、CL、DH、DL，其中 H 就是 High（高位），L 就是 Low（低位）。

如此一来，比较长的数据也能暂存，比较短的数据也能暂存。（16 位相对于计算机刚刚起步的时代，已经算长了）

#### 控制单元的寄存器

控制单元中，IP 寄存器就是指令指针寄存器（Instruction Pointer Register)，指向代码段中下一条指令的位置。CPU 会根据它来不断地将指令从内存的代码段中，加载到 CPU 的指令队列中，然后交给运算单元去执行。

每个进程都分代码段和数据段，为了指向不同进程的地址空间，有四个 16 位的段寄存器，分别是 CS、DS、SS、ES。

其中，**CS** 就是**代码段寄存器（Code Segment Register）**，通过它可以找到代码在内存中的位置；**DS** 是**数据段寄存器（Data Segment Register）**，通过它可以找到数据在内存中的位置。

**SS** 是**栈寄存器（Stack Segment Register）**。栈是程序运行中一个特殊的数据结构，数据的存取只能从一端进行，秉承后进先出的原则，push 就是入栈，pop 就是出栈。

![06_05_stack_register.png](https://i.loli.net/2021/08/04/x9wOzdZhvp2XVFt.png)

凡是与函数调用相关的操作，都与栈紧密相关。例如，A 调用 B，B 调用 C。

- 当 A 调用 B 的时候，要执行 B 函数的逻辑，因而 A 运行的相关信息就会被 push 到栈里面。
- 当 B 调用 C 的时候，同样，B 运行相关信息会被 push 到栈里面，然后才运行 C 函数的逻辑。
- 当 C 运行完毕的时候，先 pop 出来的是 B，B 就接着调用 C 之后的指令运行下去。
- B 运行完了，再 pop 出来的就是 A，A 接着运行，直到结束。

如果运算中需要加载内存中的数据，需要通过 DS 找到内存中的数据，加载到通用寄存器中，应该如何加载呢？

对于一个段，有一个起始的地址，而段内的具体位置，称为偏移量（Offset）。

> [!ATTENTION]
> 在 CS 和 DS 中都存放着一个段的起始地址。代码段的偏移量在 IP 寄存器中，数据段的偏移量会放在通用寄存器中。

CS 和 DS 都是 16 位的，也就是说，起始地址都是 16 位的，IP 寄存器和通用寄存器都是 16 位的，偏移量也是 16 位的，但是 8086 的地址总线地址是 20 位。怎么凑够这 20 位呢？

方法就是“**起始地址 *16+ 偏移量**”，也就是把 CS 和 DS 中的值左移 4 位，变成 20 位的，加上 16 位的偏移量，这样就可以得到最终 20 位的数据地址。

从这个计算方式可以算出，无论真正的内存多么大，对于只有 20 位地址总线的 8086 来讲，能够区分出的地址也就 2^20=1M，超过这个空间就访问不到了。如果你想访问 1M+X 的地方，这个位置已经超过 20 位了，由于地址总线只有 20 位，在总线上超过 20 位的部分根本是发不出去的，所以发出去的还是 X，最后还是会访问 1M 内的 X 的位置。

那一个段最大能有多大呢？因为偏移量只能是 16 位的，所以一个段最大的大小是 2^16=64k。

对于 8086 CPU，最多只能访问 1M 的内存空间，还要分成多个段，每个段最多 64K。尽管我们现在看来这不可想象的小，根本没法儿用，但是在当时其实够用了。

### 32 位寄存器

计算机的发展日新月异，内存越来越大，总线也越来越宽。在 32 位处理器中，有 32 根地址总线，可以访问 2^32=4G 的内存。

使用原来的模式肯定不行了，但是又不能完全抛弃原来的模式，那么在这种开放架构的基础上，如何保持兼容呢？

#### 通用寄存器的扩展

将 8 个 16 位的扩展到 8 个 32 位的，但是依然可以保留 16 位的和 8 位的使用方式。为什么高 16 位不分成两个 8 位使用呢？因为这样就不兼容了！

![06_06_32_register.png](https://i.loli.net/2021/08/04/MYdglmnBU3fJLSz.png)

#### 段寄存器的扩展

原来的模式其实有点不伦不类，因为它没有把 16 位当成一个段的起始地址，也没有按 8 位或者 16 位扩展的形式，而是根据当时的硬件，弄了一个不上不下的 20 位的地址。这样每次都要左移四位，也就意味着段的起始地址不能是任何一个地方，只是能整除 16 的地方。

经过重新定义，CS、SS、DS、ES 仍然是 16 位的，但是不再是段的起始地址。段的起始地址放在内存的某个地方。这个地方是一个表格，表格中的一项一项是段描述符（Segment Descriptor）。这里面才是真正的段的起始地址。而段寄存器里面保存的是在这个表格中的哪一项，称为选择子（Selector）。

如此一来，将一个从段寄存器直接拿到的段起始地址，就变成了先间接地从段寄存器找到表格中的一项，再从表格中的一项中拿到段起始地址。

这样段起始地址就会很灵活了。当然为了快速拿到段起始地址，段寄存器会从内存中拿到 CPU 的描述符高速缓存器中。

这样就不兼容了，咋办呢？好在后面这种模式灵活度非常高，可以保持将来一直兼容下去。

因此，32 位的系统架构下，我们将前一种模式称为**实模式（Real Pattern）**，后一种模式称为**保护模式（Protected Pattern）**。

**不能无缝兼容，但是通过切换模式兼容，也是可以接受的。**

当系统刚刚启动的时候，CPU 是处于实模式的，这个时候和原来的模式是兼容的。也就是说，哪怕你买了 32 位的 CPU，也支持在原来的模式下运行，只不过快了一点而已。
当需要更多内存的时候，可以遵循一定的规则，进行一系列的操作，然后切换到保护模式，就能够用到 32 位 CPU 更强大的能力。

## 总结

以后的操作系统讲解中，也是主要基于 x86 架构进行讲解。
只有了解了底层硬件的基本工作原理，将来才能理解操作系统的工作模式。

![06_07_x86_architecture.png](https://i.loli.net/2021/08/04/KC4IBdHwGzW7rsA.png)

> [!TIP]
> 建议重点牢记寄存器的作用，以及段的工作模式。

## 汇编命令基础

操作底层的寄存器往往需要使用汇编语言，操作系统的一些底层的模块也是用汇编语言写的。

### 常用汇编命令

- mov
- call
- jmp
- int
- ret
- add
- or
- xor
- shl
- shr
- push
- pop
- inc
- dec
- sub
- cmp


## 拓展阅读 

[《汇编从零开始到C语言》](https://study.163.com/course/introduction.htm?courseId=1640004#/courseDetail?tab=1)

[Guide to x86 Assembly](http://www.cs.virginia.edu/~evans/cs216/guides/x86.html)

[Go Plan 9 汇编入门](https://www.bilibili.com/video/av46494102)

《深入理解计算机系统》 第三章

《浪潮之巅-上》 第五章