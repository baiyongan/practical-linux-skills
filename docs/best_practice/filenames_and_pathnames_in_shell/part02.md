# 2 错误操作

但是为什么你需要遵守这些规则呢？ 找出问题的最简单方法是查看一些错误的示例，因为要真正了解如何修复问题，你需要知道哪里出了问题。这些示例假定默认设置（例如，没有"set -f”或"IFS=...”）：

```shell
cat * > ../collection  # 错误
```

这种方式是错误的。如果当前目录中的文件名以"-”开头，则会被误解为选项而不是文件名。 例如，如果有一个名为"-n”的文件，它会立即启用 cat 的"-n”选项，而不是视作要被 cat 的一个文件（GNU cat 就是这样做，它会为行编号）。 一般来说，你不应该有一个以 `"*”` 开头的glob——它应该以 "./” 为前缀。 此外，如果目录中没有（未隐藏的）文件，则 glob 模式将改为返回模式（`"*”`）； 这意味着命令 (cat) 将尝试打开一个不可能的名为"*”的文件。

```shell
for file in * ; do  # 错误
  cat "$file" >> ../collection
done
```

也是错误的，出于同样的原因； 名为"-n”的文件会欺骗 cat 程序，如果模式不匹配，它将以模式本身作为值循环一次。

```shell
cat $(find . -type f) > ../collection  # 错误
```

错误。 如果任何路径名包含空格、换行符或制表符，则其名称将被拆分（文件"a b”将被错误地解析为"a”和"b”两个文件）。 如果路径名包含像 * 这样的通配符，shell 将尝试扩展它，这可能会产生其他问题。 此外，如果 find 命令不匹配任何文件，则该命令将不带参数运行； 在许多命令（如 cat）上，这将导致程序挂在标准输入的输入上（你可以通过附加路径名 /dev/null 来解决这个问题，但很多人不知道这样做）。

```shell
( for file in $(find . -type f) ; do  # 错误
    cat "$file"
  done ) > ../collection
```

错误，出于类似的原因。 这会分解包含空格、换行符或制表符的路径名，并且如果路径名本身包含诸如"*”之类的字符，则会错误地扩展路径名。

```shell
 ( find . -type f |    
   while read file ; do cat "$file" ; done ) > ../collection # 错误
```

错误。 如果路径名中间有空格，则此方法有效，但如果路径名以空格开头或结尾（它们会被截断），则此方法将无法正常工作。 此外，如果路径名包含`"\”`，它会被破坏； 特别是，如果它以`"\”`结尾，它将与下一个路径名组合（删除两者）。 通常，在 shell 中使用不带`"-r”`选项的"read”通常是错误的，在许多情况下，你应该在读取之前设置 IFS=""。

```shell
( find . -type f | xargs cat ) > ../collection # 错误
```

错误。 默认情况下，xargs 的输入被解析，因此空格字符（以及换行符）分隔参数，反斜杠、单引号、双引号和 & 字符用于引用。 根据 POSIX 标准，你必须考虑到选项 -E "" ，或下划线也可能具有特殊含义。 请注意，POSIX 标准 xargs 部分中的许多示例都是错误的； 带有空格、换行符或许多其他字符的路径名将导致许多示例失败。

```shell
 ( find . -type f |
   while IFS="" read -r file ; do cat "$file" ; done ) \
          > ../collection # 错误
```

错误。 像许多程序一样，这种写法，假设你可以拥有路径名列表，且每行一个路径名。 但是由于路径名可以在内部包含换行符，所以所有简单的对路径名一次一行处理的方式，都是错误的！ 如果路径名不能包含换行符，则这种构造还好，但由于许多类 Unix 系统允许，攻击者很乐意使用此错误假设作为攻击。

```shell
cat $file # 错误
```

错误。 如果 `$file` 包含空格，那么它可以分解并解释为多个文件名，如果 `$file` 以破折号开头，则该名称将被解释为一个选项。 此外，如果 `$file` 包含像 "*” 这样的元字符，它将首先被扩展，产生错误的文件名集。

